# AUTOGENERATED FROM: jlabdev/convert.ipynb

# Cell: 0
from typing import List, Dict, Optional
import json
import os
import sys


# Cell: 1
def _get_files(folder: str = ".") -> List[str]:
    file_paths = []
    for root, dirs, files in os.walk(folder):
        if ".ipynb_checkpoints" in root:
            continue
        files = map(_join_path_cleanly, [root], files)
        file_paths.extend(files)
    return file_paths


# Cell: 2
def _join_path_cleanly(root, fname):
    joined_path = os.path.join(root, fname)
    linux_style_path = joined_path.replace("\\", "/")
    root_free_path = linux_style_path.replace("./", "")
    return root_free_path


# Cell: 3
def _is_notebook(file_name):
    return file_name.endswith(".ipynb")


# Cell: 4
def _get_notebooks(folder: str = ".") -> List[str]:
    files = _get_files(folder)
    notebooks =  filter(_is_notebook, files)
    return list(notebooks)


# Cell: 5
def _get_notebook(file_path: str) -> Dict:
    with open(file_path, "r", encoding="utf8") as f:
        return json.loads(f.read())


# Cell: 6
def _is_non_empty_code_cell(cell):
    return cell["cell_type"] == "code" and len(cell["source"]) > 0


# Cell: 7
def _is_convertible_nb(data) -> str:
    for cell in data["cells"]:
        if not _is_non_empty_code_cell(cell):
            continue
        if cell["source"][0].startswith("#convert"):
            return True
    return False


# Cell: 8
def _get_exportable_cells(data):
    return list(filter(_is_exportable_cell, data["cells"]))


# Cell: 9
def _update_cell_header(cell, cell_idx):
    cell["source"][0] = cell["source"][0].replace("#export", "# Cell: {}".format(cell_idx))


# Cell: 10
def _combine_cells_to_code(cells, file_path: str) -> str:
    code = "# AUTOGENERATED FROM: {}\n\n".format(file_path)
    for cell_idx, cell in enumerate(cells):
        _update_cell_header(cell, cell_idx)
        # Add cell source to code
        code += "".join(cell["source"])
        
        # Ensure there are two empty lines between cells
        code += "\n\n\n"
        while code.endswith("\n\n\n\n"):
            code = code[:-2]
    
    # Ensure there is a single new line at file end.
    while code.endswith("\n\n"):
        code = code[:-2]
    return code


# Cell: 11
def _get_py_paths(file_path: str, root: str="."):
    py_package = file_path.replace("/", ".").replace("..", ".").replace(".ipynb", "")
    py_path = os.path.join(root, py_package.replace(".", os.sep) + ".py")
    package_path = os.path.join(root, os.sep.join(py_package.split(".")[:-1]))
    return py_path, package_path


# Cell: 12
def _write_py(code, file_path: str, root: str= ".") -> None:
    py_path, package_path = _get_py_paths(file_path, root)
    os.makedirs(package_path, exist_ok=True)
    with open(py_path, "w", encoding="utf8") as f:
        f.write(code)


# Cell: 13
def notebook2py(project_root: str = ".") -> None:
    """
    Convert all notebooks in the folder.
    
    :param project_root: The root directory of the project. The default exp path is relative to this folder.
    :param nb_root: The root directory of all the notebooks. Only notebooks in this or any subfolder will be considered.
    """
    notebooks = _get_notebooks(project_root)
    for file_path in notebooks:
        print("Converting to py: {}".format(file_path))
        notebook = _get_notebook(file_path)
        if _is_convertible_nb(notebook): 
            exportable_cells = _get_exportable_cells(notebook)
            code = _combine_cells_to_code(exportable_cells, file_path)
            _write_py(code, file_path, root=project_root)


# Cell: 14
def _extract_doc(source:str) -> str:
    lines = source.split("\n")
    docs = []
    mode = 0
    current_doc = []
    for orig_line in lines:
        line = orig_line.lstrip()
        indent = len(orig_line) - len(line)
        if mode != 2:
            if (line.startswith("def ") or line.startswith("class ")) and not (line.startswith("def _") or line.startswith("class _")):
                if mode == 1:
                    docs.append(current_doc)
                level = int(indent / 4) + 1
                if line.startswith("class "):
                    fun_name = line.split(" ")[1].split("(")[0]
                    line = line.replace(fun_name, "**" + fun_name + "**")
                    line = line.replace("class", "*class*")
                    line = line.replace("self", "*self*")
                    current_doc = [("#"*level) + " " + line[:-1], ""]
                else:
                    fun_name = line.split(" ")[1].split("(")[0]
                    line = line.replace(fun_name, "**" + fun_name + "**")
                    line = line.replace("def", "*def*")
                    line = line.replace("self", "*self*")
                    current_doc = ["### " + line[:-1] + "", ""]
                mode = 1
                continue
        if mode == 1:
            if "\"\"\"" in line:
                mode = 2
        elif mode == 2:
            if "\"\"\"" in line:
                mode = 0
                docs.append(current_doc)
                current_doc = []
            else:
                current_doc[1] += line.lstrip() + "\n"                

    if len(current_doc) > 0:
        docs.append(current_doc)

    if len(docs) == 0:
        return ""
    
    output = ""
    for doc in docs:
        output += doc[0] + "\n\n"
        if doc[1] == "":
            doc[1] = "*(no documentation found)*"
        output += doc[1].replace(":param", "*").replace(":return:", "* returns:")
        output += "\n\n"
        
    return output


# Cell: 15
def _get_doc(data) -> str:
    doc = ""
    title = None
    for cell in data["cells"]:
        # Example Cell
        if cell["cell_type"] == "code" and len(cell["source"]) > 0 and not cell["source"][0].startswith("#export") and not cell["source"][0].startswith("#hide") and not cell["source"][0].startswith("#convert"):
            doc += "Example:\n"
            doc += "```python\n"
            for line in cell["source"]:
                doc += line
            doc += "\n```\n"
            doc += "Output:\n"
            doc += "```\n"
            for outp in cell["outputs"]:
                if "text" in outp:
                    for entry in outp["text"]:
                        doc += entry
                if "traceback" in outp:
                    for entry in outp["traceback"]:
                        while entry.find('\x1b') >= 0:
                            start = entry.find('\x1b')
                            end = entry.find("m", start)
                            entry = entry[:start] + entry[end+1:]
                        doc += entry + "\n"
            doc += "\n```\n"
            doc += "\n"

        # Export Cell
        if cell["cell_type"] == "code" and len(cell["source"]) > 0 and cell["source"][0].startswith("#export"):
            source = "".join(cell["source"])
            doc += _extract_doc(source)
            
        # Regular Markdown Cell
        if cell["cell_type"] == "markdown" and len(cell["source"]) > 0 and not cell["source"][0].startswith("#hide"):
            for line in cell["source"]:
                if line.startswith("# ") and title is None:
                    title = line[2:]
                doc += line
            doc += "\n\n"
    return doc, title


# Cell: 16
def _write_md(file_path, root: str = ".") -> str:
    notebook = _get_notebook(file_path)
    if not _is_convertible_nb(notebook):
        return None, None
    doc_path = os.path.join(root, "docs")
    os.makedirs(doc_path, exist_ok=True)
    
    py_package = file_path.replace("/", ".").replace("..", ".").replace(".ipynb", "")
    md_name = py_package.replace(".", "/") + ".md"
    md_path = os.path.join(root, "docs", md_name).replace("\\", "/")
    doc, title = _get_doc(notebook)
    path = "/".join(md_path.split("/")[:-1])
    if not os.path.exists(path):
        os.makedirs(path)
    with open(md_path, "w", encoding="utf8") as f:
        f.write(doc)
    return md_name, title


# Cell: 17
README_TEMPLATE = """
# Package List

{toc}

"""


# Cell: 18
def notebook2md(project_root: str = ".") -> None:
    """
    Convert all notebooks in the folder.
    
    :param project_root: The root directory of the project. The default exp path is relative to this folder.
    :param nb_root: The root directory of all the notebooks. Only notebooks in this or any subfolder will be considered.
    """
    readme_template = README_TEMPLATE
    notebooks = _get_notebooks(project_root)
    index = []
    for nb_path in notebooks:
        print("Converting to md: {}".format(nb_path))
        name, title = _write_md(nb_path, root=project_root)
        if name is not None:
            index.append((name, title))
    
    index = sorted(index, key=lambda x: x[1])
    
    if len(index) > 0:
        with open(os.path.join(project_root, "docs", "README.md"), "w", encoding="utf8") as f:
            toc = ""
            for i in index:
                toc += "* [{}]({})\n".format(i[1], i[0])
            readme_template = readme_template.replace("`{toc}`", "`#toc%`").format(toc=toc).replace("`#toc%`", "`{toc}`")
            f.write(readme_template)


# Cell: 19
def _get_python_files(folder: str = ".") -> List[str]:
    pys = []
    for root, dirs, files in os.walk(folder):
        if ".ipynb_checkpoints" in root:
            continue
        for fname in files:
            if fname.endswith(".py"):
                pys.append(os.path.join(root, fname).replace("\\", "/").replace("./", ""))
    return pys


# Cell: 20
def _get_py_cells(py_file):
    with open(py_file, "r", encoding="utf8") as f:
        data = f.read()
    if not data.startswith("# AUTOGENERATED FROM: "):
        return None, None
    
    lines = data.split("\n")
    file_path = lines[0].replace("# AUTOGENERATED FROM: ", "")
    cells = []
    current_cell = []
    header = True
    for line in lines:
        if line.startswith("# Cell:"):
            if not header:
                cells.append(current_cell)
            header = False
            current_cell = []
            continue
        if not header:
            current_cell.append(line)
    if not header:
        cells.append(current_cell)
    for i in range(len(cells)):
        cells[i] = "\n".join(cells[i])
        while cells[i].endswith("\n"):
            cells[i] = cells[i][:-1]
        cells[i] = cells[i].split("\n")
        for idx in range(len(cells[i]) -1):
            cells[i][idx] += "\n"
    return file_path, cells


# Cell: 21
def _overwrite_exported_cells(data, cells):
    i = 0
    for cell in data["cells"]:
        if cell["cell_type"] == "code" and len(cell["source"]) > 0 and cell["source"][0].startswith("#export"):
            cell["source"] = ["#export\n"] + cells[i]
            i += 1


# Cell: 22
def _save_notebook(file_path: str, notebook: Dict) -> None:
    with open(file_path, "w", encoding="utf8") as f:
        return f.write(json.dumps(notebook, indent=1) + "\n")


# Cell: 23
def python2nb(project_root: str = ".") -> None:
    """
    Convert all notebooks in the folder.
    
    :param project_root: The root directory of the project. The default exp path is relative to this folder.
    :param nb_root: The root directory of all the notebooks. Only notebooks in this or any subfolder will be considered.
    """
    readme_template = README_TEMPLATE
    pyfiles = _get_python_files(project_root)
    index = []
    for py_path in pyfiles:
        print("Converting to notebook: {}".format(py_path))
        
        file_path, exported_cells = _get_py_cells(py_path)
        if file_path is not None:
            notebook = _get_notebook(file_path)
            _overwrite_exported_cells(notebook, exported_cells)
            _save_notebook(file_path, notebook)
            print("Updated notebook: {}".format(file_path))


# Cell: 24
if __name__ == "__main__":
    if "--nb2py" in sys.argv:
        notebook2py()
    if "--nb2md" in sys.argv:
        notebook2md()
    if "--py2nb" in sys.argv:
        python2nb()
